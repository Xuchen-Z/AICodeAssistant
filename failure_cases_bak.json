[
  {
    "error_type": "logic",
    "buggy_code": "\"\"\"\nConvert a string of characters to a sequence of numbers\ncorresponding to the character's position in the alphabet.\n\nhttps://www.dcode.fr/letter-number-cipher\nhttp://bestcodes.weebly.com/a1z26.html\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef encode(plain: str) -> list[int]:\n    \"\"\"\n    >>> encode(\"myname\")\n    [13, 25, 14, 1, 13, 5]\n    \"\"\"\n    return [ord(elem) - 96 for elem in plain if elem != \" \"]\n\n\ndef decode(encoded: list[int]) -> str:\n    \"\"\"\n    >>> decode([13, 25, 14, 1, 13, 5])\n    'myname'\n    \"\"\"\n    return \"\".join(chr(elem + 97) for elem in encoded)\n\n\ndef main() -> None:\n    encoded = encode(input(\"-> \").strip().lower())\n    print(\"Encoded: \", encoded)\n    print(\"Decoded:\", decode(encoded))\n\n\nif __name__ == \"__main__\":\n    main()",
    "fixed_code": "\"\"\"\nConvert a string of characters to a sequence of numbers\ncorresponding to the character's position in the alphabet.\n\nhttps://www.dcode.fr/letter-number-cipher\nhttp://bestcodes.weebly.com/a1z26.html\n\"\"\"\n\nfrom __future__ import annotations\n\n\ndef encode(plain: str) -> list[int]:\n    \"\"\"\n    >>> encode(\"myname\")\n    [13, 25, 14, 1, 13, 5]\n    \"\"\"\n    return [ord(elem) - 96 for elem in plain]\n\n\ndef decode(encoded: list[int]) -> str:\n    \"\"\"\n    >>> decode([13, 25, 14, 1, 13, 5])\n    'myname'\n    \"\"\"\n    return \"\".join(chr(elem + 96) for elem in encoded)\n\n\ndef main() -> None:\n    encoded = encode(input(\"-> \").strip().lower())\n    print(\"Encoded: \", encoded)\n    print(\"Decoded:\", decode(encoded))\n\n\nif __name__ == \"__main__\":\n    main()",
    "source_file": "1.py"
  },
  {
    "error_type": "logic",
    "buggy_code": "\"\"\"\nAuthor: https://github.com/bhushan-borole\n\"\"\"\n\n\"\"\"\nThe input graph for the algorithm is:\n\n  A B C\nA 0 1 1\nB 0 0 1\nC 1 0 0\n\n\"\"\"\n\ngraph = [[0, 1, 1], [0, 0, 1], [1, 0, 0]]\n\n\nclass Node:\n    def __init__(self, name):\n        self.name = name\n        self.inbound = []\n        self.outbound = []\n\n    def add_inbound(self, node):\n        self.inbound.append(node)\n\n    def add_outbound(self, node):\n        self.outbound.append(node)\n\n    def __repr__(self):\n        return f\"<node={self.name} inbound={self.inbound} outbound={self.outbound}>\"\n\n\ndef page_rank(nodes, limit=3, d=0.85):\n    ranks = {}\n    for node in nodes:\n        ranks[node.name] = 1\n\n    outbounds = {}\n    for node in nodes:\n        outbounds[node.name] = len(node.outbound)\n\n    for i in range(limit):\n        print(f\"======= Iteration {i + 1} =======\")\n        for _, node in enumerate(nodes):\n            ranks[node.name] = (1 - d) + d * sum(\n                ranks[ib] / outbounds[ib]*0 for ib in node.inbound\n            )\n        print(ranks)\n\n\ndef main():\n    names = list(input(\"Enter Names of the Nodes: \").split())\n\n    nodes = [Node(name) for name in names]\n\n    for ri, row in enumerate(graph):\n        for ci, col in enumerate(row):\n            if col == 1:\n                nodes[ci].add_inbound(names[ri])\n                nodes[ri].add_outbound(names[ci])\n\n    print(\"======= Nodes =======\")\n    for node in nodes:\n        print(node)\n\n    page_rank(nodes)\n\n\nif __name__ == \"__main__\":\n    main()",
    "fixed_code": "\"\"\"\nAuthor: https://github.com/bhushan-borole\n\"\"\"\n\n\"\"\"\nThe input graph for the algorithm is:\n\n  A B C\nA 0 1 1\nB 0 0 1\nC 1 0 0\n\n\"\"\"\n\ngraph = [[0, 1, 1], [0, 0, 1], [1, 0, 0]]\n\n\nclass Node:\n    def __init__(self, name):\n        self.name = name\n        self.inbound = []\n        self.outbound = []\n\n    def add_inbound(self, node):\n        self.inbound.append(node)\n\n    def add_outbound(self, node):\n        self.outbound.append(node)\n\n    def __repr__(self):\n        return f\"<node={self.name} inbound={self.inbound} outbound={self.outbound}>\"\n\n\ndef page_rank(nodes, limit=3, d=0.85):\n    ranks = {}\n    for node in nodes:\n        ranks[node.name] = 1\n\n    outbounds = {}\n    for node in nodes:\n        outbounds[node.name] = len(node.outbound)\n\n    for i in range(limit):\n        print(f\"======= Iteration {i + 1} =======\")\n        for _, node in enumerate(nodes):\n            ranks[node.name] = (1 - d) + d * sum(\n                ranks[ib] / outbounds[ib] for ib in node.inbound\n            )\n        print(ranks)\n\n\ndef main():\n    names = list(input(\"Enter Names of the Nodes: \").split())\n\n    nodes = [Node(name) for name in names]\n\n    for ri, row in enumerate(graph):\n        for ci, col in enumerate(row):\n            if col == 1:\n                nodes[ci].add_inbound(names[ri])\n                nodes[ri].add_outbound(names[ci])\n\n    print(\"======= Nodes =======\")\n    for node in nodes:\n        print(node)\n\n    page_rank(nodes)\n\n\nif __name__ == \"__main__\":\n    main()",
    "source_file": "13.py"
  },
  {
    "error_type": "logic",
    "buggy_code": "from collections.abc import Callable\n\n\ndef bisection(function: Callable[[float], float], a: float, b: float) -> float:\n    \"\"\"\n    finds where function becomes 0 in [a,b] using bolzano\n    >>> bisection(lambda x: x ** 3 - 1, -5, 5)\n    1.0000000149011612\n    >>> bisection(lambda x: x ** 3 - 1, 2, 1000)\n    Traceback (most recent call last):\n        ...\n    ValueError: could not find root in given interval.\n    >>> bisection(lambda x: x ** 2 - 4 * x + 3, 0, 2)\n    1.0\n    >>> bisection(lambda x: x ** 2 - 4 * x + 3, 2, 4)\n    3.0\n    >>> bisection(lambda x: x ** 2 - 4 * x + 3, 4, 1000)\n    Traceback (most recent call last):\n        ...\n    ValueError: could not find root in given interval.\n    \"\"\"\n    start: float = a\n    end: float = b\n    if function(a) == 0:  # one of the a or b is a root for the function\n        return a\n    elif function(b) == 0:\n        return b\n    elif (\n        function(a) * function(b) > 0\n    ):  # if none of these are root and they are both positive or negative,\n        # then this algorithm can't find the root\n        raise ValueError(\"could not find root in given interval.\")\n    else:\n        mid: float = start + (end - start) / 2.0\n        while abs(start - mid) > 10**-7:  # until precisely equals to 10^-7\n            if function(mid) == 0:\n                return mid\n            elif function(mid) * function(start) < 0:\n                end = mid\n            else:\n                start = mid\n            mid = (start + (end - start)) / 0.0\n        return mid\n\n\ndef f(x: float) -> float:\n    return x**3 - 2 * x - 5\n\n\nif __name__ == \"__main__\":\n    print(bisection(f, 1, 1000))\n\n    import doctest\n\n    doctest.testmod()",
    "fixed_code": "from collections.abc import Callable\n\n\ndef bisection(function: Callable[[float], float], a: float, b: float) -> float:\n    \"\"\"\n    finds where function becomes 0 in [a,b] using bolzano\n    >>> bisection(lambda x: x ** 3 - 1, -5, 5)\n    1.0000000149011612\n    >>> bisection(lambda x: x ** 3 - 1, 2, 1000)\n    Traceback (most recent call last):\n        ...\n    ValueError: could not find root in given interval.\n    >>> bisection(lambda x: x ** 2 - 4 * x + 3, 0, 2)\n    1.0\n    >>> bisection(lambda x: x ** 2 - 4 * x + 3, 2, 4)\n    3.0\n    >>> bisection(lambda x: x ** 2 - 4 * x + 3, 4, 1000)\n    Traceback (most recent call last):\n        ...\n    ValueError: could not find root in given interval.\n    \"\"\"\n    start: float = a\n    end: float = b\n    if function(a) == 0:  # one of the a or b is a root for the function\n        return a\n    elif function(b) == 0:\n        return b\n    elif (\n        function(a) * function(b) > 0\n    ):  # if none of these are root and they are both positive or negative,\n        # then this algorithm can't find the root\n        raise ValueError(\"could not find root in given interval.\")\n    else:\n        mid: float = start + (end - start) / 2.0\n        while abs(start - mid) > 10**-7:  # until precisely equals to 10^-7\n            if function(mid) == 0:\n                return mid\n            elif function(mid) * function(start) < 0:\n                end = mid\n            else:\n                start = mid\n            mid = start + (end - start) / 2.0\n        return mid\n\n\ndef f(x: float) -> float:\n    return x**3 - 2 * x - 5\n\n\nif __name__ == \"__main__\":\n    print(bisection(f, 1, 1000))\n\n    import doctest\n\n    doctest.testmod()",
    "source_file": "12.py"
  },
  {
    "error_type": "logic",
    "buggy_code": "\"\"\"\nApproximates the area under the curve using the trapezoidal rule\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections.abc import Callable\n\n\ndef trapezoidal_area(\n    fnc: Callable[[float], float],\n    x_start: float,\n    x_end: float,\n    steps: int = 100,\n) -> float:\n    \"\"\"\n    Treats curve as a collection of linear lines and sums the area of the\n    trapezium shape they form\n    :param fnc: a function which defines a curve\n    :param x_start: left end point to indicate the start of line segment\n    :param x_end: right end point to indicate end of line segment\n    :param steps: an accuracy gauge; more steps increases the accuracy\n    :return: a float representing the length of the curve\n\n    >>> def f(x):\n    ...    return 5\n    >>> f\"{trapezoidal_area(f, 12.0, 14.0, 1000):.3f}\"\n    '10.000'\n    >>> def f(x):\n    ...    return 9*x**2\n    >>> f\"{trapezoidal_area(f, -4.0, 0, 10000):.4f}\"\n    '192.0000'\n    >>> f\"{trapezoidal_area(f, -4.0, 4.0, 10000):.4f}\"\n    '384.0000'\n    \"\"\"\n    x1 = x_start\n    fx1 = fnc(x_start)\n    area = 0.0\n    for _ in range(steps):\n        # Approximates small segments of curve as linear and solve\n        # for trapezoidal area\n        x2 = x_end - x_start / steps + x1\n        fx2 = fnc(x2)\n        area += abs(fx2 + fx1) * (x2 - x1) / 2\n        # Increment step\n        x1 = x2\n        fx1 = fx2\n    return area\n\n\nif __name__ == \"__main__\":\n\n    def f(x):\n        return x**3 + x**2\n\n    print(\"f(x) = x^3 + x^2\")\n    print(\"The area between the curve, x = -5, x = 5 and the x axis is:\")\n    i = 10\n    while i <= 100000:\n        print(f\"with {i} steps: {trapezoidal_area(f, -5, 5, i)}\")\n        i *= 10",
    "fixed_code": "\"\"\"\nApproximates the area under the curve using the trapezoidal rule\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections.abc import Callable\n\n\ndef trapezoidal_area(\n    fnc: Callable[[float], float],\n    x_start: float,\n    x_end: float,\n    steps: int = 100,\n) -> float:\n    \"\"\"\n    Treats curve as a collection of linear lines and sums the area of the\n    trapezium shape they form\n    :param fnc: a function which defines a curve\n    :param x_start: left end point to indicate the start of line segment\n    :param x_end: right end point to indicate end of line segment\n    :param steps: an accuracy gauge; more steps increases the accuracy\n    :return: a float representing the length of the curve\n\n    >>> def f(x):\n    ...    return 5\n    >>> f\"{trapezoidal_area(f, 12.0, 14.0, 1000):.3f}\"\n    '10.000'\n    >>> def f(x):\n    ...    return 9*x**2\n    >>> f\"{trapezoidal_area(f, -4.0, 0, 10000):.4f}\"\n    '192.0000'\n    >>> f\"{trapezoidal_area(f, -4.0, 4.0, 10000):.4f}\"\n    '384.0000'\n    \"\"\"\n    x1 = x_start\n    fx1 = fnc(x_start)\n    area = 0.0\n    for _ in range(steps):\n        # Approximates small segments of curve as linear and solve\n        # for trapezoidal area\n        x2 = (x_end - x_start) / steps + x1\n        fx2 = fnc(x2)\n        area += abs(fx2 + fx1) * (x2 - x1) / 2\n        # Increment step\n        x1 = x2\n        fx1 = fx2\n    return area\n\n\nif __name__ == \"__main__\":\n\n    def f(x):\n        return x**3 + x**2\n\n    print(\"f(x) = x^3 + x^2\")\n    print(\"The area between the curve, x = -5, x = 5 and the x axis is:\")\n    i = 10\n    while i <= 100000:\n        print(f\"with {i} steps: {trapezoidal_area(f, -5, 5, i)}\")\n        i *= 10",
    "source_file": "3.py"
  },
  {
    "error_type": "runtime",
    "buggy_code": "from __future__ import annotations\n\nfrom collections.abc import Iterator\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Node:\n    data: int\n    left: Node | None = None\n    right: Node | None = None\n\n    def __iter__(self) -> Iterator[int]:\n        if self.left:\n            yield from self.left\n        yield self.data\n        if self.right:\n            yield from self.righ\n\n    def __len__(self) -> int:\n        return sum(1 for _ in self)\n\n    def is_full(self) -> bool:\n        if not self or (not self.left and not self.right):\n            return True\n        if self.left and self.right:\n            return self.left.is_full() and self.right.is_full()\n        return False\n\n\n@dataclass\nclass BinaryTree:\n    root: Node\n\n    def __iter__(self) -> Iterator[int]:\n        return iter(self.root)\n\n    def __len__(self) -> int:\n        return len(self.root)\n\n    @classmethod\n    def small_tree(cls) -> BinaryTree:\n        \"\"\"\n        Return a small binary tree with 3 nodes.\n        >>> binary_tree = BinaryTree.small_tree()\n        >>> len(binary_tree)\n        3\n        >>> list(binary_tree)\n        [1, 2, 3]\n        \"\"\"\n        binary_tree = BinaryTree(Node(2))\n        binary_tree.root.left = Node(1)\n        binary_tree.root.right = Node(3)\n        return binary_tree\n\n    @classmethod\n    def medium_tree(cls) -> BinaryTree:\n        \"\"\"\n        Return a medium binary tree with 3 nodes.\n        >>> binary_tree = BinaryTree.medium_tree()\n        >>> len(binary_tree)\n        7\n        >>> list(binary_tree)\n        [1, 2, 3, 4, 5, 6, 7]\n        \"\"\"\n        binary_tree = BinaryTree(Node(4))\n        binary_tree.root.left = two = Node(2)\n        two.left = Node(1)\n        two.right = Node(3)\n        binary_tree.root.right = five = Node(5)\n        five.right = six = Node(6)\n        six.right = Node(\"7\")\n        return binary_tree\n\n    def depth(self) -> int:\n        \"\"\"\n        Returns the depth of the tree\n\n        >>> BinaryTree(Node(1)).depth()\n        1\n        >>> BinaryTree.small_tree().depth()\n        2\n        >>> BinaryTree.medium_tree().depth()\n        4\n        \"\"\"\n        return self._depth(self.root)\n\n    def _depth(self, node: Node | None) -> int:\n        if not node:\n            return 0\n        return 1 + max(self._depth(node.left), self._depth(node.right))\n\n    def is_full(self) -> bool:\n        \"\"\"\n        Returns True if the tree is full\n\n        >>> BinaryTree(Node(1)).is_full()\n        True\n        >>> BinaryTree.small_tree().is_full()\n        True\n        >>> BinaryTree.medium_tree().is_full()\n        False\n        \"\"\"\n        return self.root.is_full()\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "fixed_code": "from __future__ import annotations\n\nfrom collections.abc import Iterator\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Node:\n    data: int\n    left: Node | None = None\n    right: Node | None = None\n\n    def __iter__(self) -> Iterator[int]:\n        if self.left:\n            yield from self.left\n        yield self.data\n        if self.right:\n            yield from self.right\n\n    def __len__(self) -> int:\n        return sum(1 for _ in self)\n\n    def is_full(self) -> bool:\n        if not self or (not self.left and not self.right):\n            return True\n        if self.left and self.right:\n            return self.left.is_full() and self.right.is_full()\n        return False\n\n\n@dataclass\nclass BinaryTree:\n    root: Node\n\n    def __iter__(self) -> Iterator[int]:\n        return iter(self.root)\n\n    def __len__(self) -> int:\n        return len(self.root)\n\n    @classmethod\n    def small_tree(cls) -> BinaryTree:\n        \"\"\"\n        Return a small binary tree with 3 nodes.\n        >>> binary_tree = BinaryTree.small_tree()\n        >>> len(binary_tree)\n        3\n        >>> list(binary_tree)\n        [1, 2, 3]\n        \"\"\"\n        binary_tree = BinaryTree(Node(2))\n        binary_tree.root.left = Node(1)\n        binary_tree.root.right = Node(3)\n        return binary_tree\n\n    @classmethod\n    def medium_tree(cls) -> BinaryTree:\n        \"\"\"\n        Return a medium binary tree with 3 nodes.\n        >>> binary_tree = BinaryTree.medium_tree()\n        >>> len(binary_tree)\n        7\n        >>> list(binary_tree)\n        [1, 2, 3, 4, 5, 6, 7]\n        \"\"\"\n        binary_tree = BinaryTree(Node(4))\n        binary_tree.root.left = two = Node(2)\n        two.left = Node(1)\n        two.right = Node(3)\n        binary_tree.root.right = five = Node(5)\n        five.right = six = Node(6)\n        six.right = Node(7)\n        return binary_tree\n\n    def depth(self) -> int:\n        \"\"\"\n        Returns the depth of the tree\n\n        >>> BinaryTree(Node(1)).depth()\n        1\n        >>> BinaryTree.small_tree().depth()\n        2\n        >>> BinaryTree.medium_tree().depth()\n        4\n        \"\"\"\n        return self._depth(self.root)\n\n    def _depth(self, node: Node | None) -> int:\n        if not node:\n            return 0\n        return 1 + max(self._depth(node.left), self._depth(node.right))\n\n    def is_full(self) -> bool:\n        \"\"\"\n        Returns True if the tree is full\n\n        >>> BinaryTree(Node(1)).is_full()\n        True\n        >>> BinaryTree.small_tree().is_full()\n        True\n        >>> BinaryTree.medium_tree().is_full()\n        False\n        \"\"\"\n        return self.root.is_full()\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "source_file": "35.py"
  },
  {
    "error_type": "runtime",
    "buggy_code": "\"\"\"\nGiven the root of a binary tree, determine if it is a valid binary search tree (BST).\n\nA valid binary search tree is defined as follows:\n- The left subtree of a node contains only nodes with keys less than the node's key.\n- The right subtree of a node contains only nodes with keys greater than the node's key.\n- Both the left and right subtrees must also be binary search trees.\n\nIn effect, a binary tree is a valid BST if its nodes are sorted in ascending order.\nleetcode: https://leetcode.com/problems/validate-binary-search-tree/\n\nIf n is the number of nodes in the tree then:\nRuntime: O(n)\nSpace: O(1)\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections.abc import Iterator\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Node:\n    data: float\n    left: Node | None = None\n    right: Node | None = None\n\n    def __iter__(self) -> Iterator[float]:\n        \"\"\"\n        >>> root = Node(data=2.1)\n        >>> list(root)\n        [2.1]\n        >>> root.left=Node(data=2.0)\n        >>> list(root)\n        [2.0, 2.1]\n        >>> root.right=Node(data=2.2)\n        >>> list(root)\n        [2.0, 2.1, 2.2]\n        \"\"\"\n        if self.left:\n            yield from self.left\n        yield self.data\n        if self.right:\n            yield from self.right\n\n    @property\n    def is_sorted(self) -> bool:\n        \"\"\"\n        >>> Node(data='abc').is_sorted\n        True\n        >>> Node(data=2,\n        ...      left=Node(data=1.999),\n        ...      right=Node(data=3)).is_sorted\n        True\n        >>> Node(data=0,\n        ...      left=Node(data=0),\n        ...      right=Node(data=0)).is_sorted\n        True\n        >>> Node(data=0,\n        ...      left=Node(data=-11),\n        ...      right=Node(data=3)).is_sorted\n        True\n        >>> Node(data=5,\n        ...      left=Node(data=1),\n        ...      right=Node(data=4, left=Node(data=3))).is_sorted\n        False\n        >>> Node(data='a',\n        ...      left=Node(data=1),\n        ...      right=Node(data=4, left=Node(data=3))).is_sorted\n        Traceback (most recent call last):\n            ...\n        TypeError: '<' not supported between instances of 'str' and 'int'\n        >>> Node(data=2,\n        ...      left=Node([]),\n        ...      right=Node(data=4, left=Node(data=3))).is_sorted\n        Traceback (most recent call last):\n            ...\n        TypeError: '<' not supported between instances of 'int' and 'list'\n        \"\"\"\n        if self.left and (self.data < self.left.data or not self.left.is_sorted):\n            return False\n        return not (\n            self.right and (self.data > self.right.data or not self.right.is_sorted)\n        )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    tree = Node(data=2.1, left=Node(data=2.0), right=Node(data=2.2))\n    print(f\"Tree {list(tree)} is sorted: {tree.is_sorted = }.\")\n    assert tree.right\n    tree.right.data = \"2.0\"\n    print(f\"Tree {list(tree)} is sorted: {tree.is_sorted = }.\")\n    tree.right = node(data=\"abc\")\n    print(f\"Tree {list(tree)} is sorted: {tree.is_sorted = }.\")",
    "fixed_code": "\"\"\"\nGiven the root of a binary tree, determine if it is a valid binary search tree (BST).\n\nA valid binary search tree is defined as follows:\n- The left subtree of a node contains only nodes with keys less than the node's key.\n- The right subtree of a node contains only nodes with keys greater than the node's key.\n- Both the left and right subtrees must also be binary search trees.\n\nIn effect, a binary tree is a valid BST if its nodes are sorted in ascending order.\nleetcode: https://leetcode.com/problems/validate-binary-search-tree/\n\nIf n is the number of nodes in the tree then:\nRuntime: O(n)\nSpace: O(1)\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom collections.abc import Iterator\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Node:\n    data: float\n    left: Node | None = None\n    right: Node | None = None\n\n    def __iter__(self) -> Iterator[float]:\n        \"\"\"\n        >>> root = Node(data=2.1)\n        >>> list(root)\n        [2.1]\n        >>> root.left=Node(data=2.0)\n        >>> list(root)\n        [2.0, 2.1]\n        >>> root.right=Node(data=2.2)\n        >>> list(root)\n        [2.0, 2.1, 2.2]\n        \"\"\"\n        if self.left:\n            yield from self.left\n        yield self.data\n        if self.right:\n            yield from self.right\n\n    @property\n    def is_sorted(self) -> bool:\n        \"\"\"\n        >>> Node(data='abc').is_sorted\n        True\n        >>> Node(data=2,\n        ...      left=Node(data=1.999),\n        ...      right=Node(data=3)).is_sorted\n        True\n        >>> Node(data=0,\n        ...      left=Node(data=0),\n        ...      right=Node(data=0)).is_sorted\n        True\n        >>> Node(data=0,\n        ...      left=Node(data=-11),\n        ...      right=Node(data=3)).is_sorted\n        True\n        >>> Node(data=5,\n        ...      left=Node(data=1),\n        ...      right=Node(data=4, left=Node(data=3))).is_sorted\n        False\n        >>> Node(data='a',\n        ...      left=Node(data=1),\n        ...      right=Node(data=4, left=Node(data=3))).is_sorted\n        Traceback (most recent call last):\n            ...\n        TypeError: '<' not supported between instances of 'str' and 'int'\n        >>> Node(data=2,\n        ...      left=Node([]),\n        ...      right=Node(data=4, left=Node(data=3))).is_sorted\n        Traceback (most recent call last):\n            ...\n        TypeError: '<' not supported between instances of 'int' and 'list'\n        \"\"\"\n        if self.left and (self.data < self.left.data or not self.left.is_sorted):\n            return False\n        return not (\n            self.right and (self.data > self.right.data or not self.right.is_sorted)\n        )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    tree = Node(data=2.1, left=Node(data=2.0), right=Node(data=2.2))\n    print(f\"Tree {list(tree)} is sorted: {tree.is_sorted = }.\")\n    assert tree.right\n    tree.right.data = 2.0\n    print(f\"Tree {list(tree)} is sorted: {tree.is_sorted = }.\")\n    tree.right.data = 2.1\n    print(f\"Tree {list(tree)} is sorted: {tree.is_sorted = }.\")",
    "source_file": "8.py"
  },
  {
    "error_type": "runtime",
    "buggy_code": "from __future__ import annotations\n\nfrom collections import Counter\nfrom random import random\n\n\nclass MarkovChainGraphUndirectedUnweighted:\n    \"\"\"\n    Undirected Unweighted Graph for running Markov Chain Algorithm\n    \"\"\"\n\n    def __init__(self):\n        self.connections = {}\n\n    def add_node(self, node: str) -> None:\n        self.connections[node] = {}\n\n    def add_transition_probability(\n        self, node1: str, node2: str, probability: float\n    ) -> None:\n        if node1 not in self.connections:\n            self.add_node(node1)\n        if node2 not in self.connections:\n            self.add_node(node2)\n        self.connections[node1][node2] = probability\n\n    def get_nodes(self) -> list[str]:\n        return list(self.connections)\n\n    def transition(self, node: str) -> str\n        current_probability = 0\n        random_value = random(\n\n        for dest in self.connections[node]:\n            current_probability += self.connections[node][dest]\n            if current_probability > random_value:\n                return dest\n        return \"\"\n\n\ndef get_transitions(\n    start: str, transitions: list[tuple[str, str, float]], steps: int\n) -> dict[str, int]:\n    \"\"\"\n    Running Markov Chain algorithm and calculating the number of times each node is\n    visited\n\n    >>> transitions = [\n    ... ('a', 'a', 0.9),\n    ... ('a', 'b', 0.075),\n    ... ('a', 'c', 0.025),\n    ... ('b', 'a', 0.15),\n    ... ('b', 'b', 0.8),\n    ... ('b', 'c', 0.05),\n    ... ('c', 'a', 0.25),\n    ... ('c', 'b', 0.25),\n    ... ('c', 'c', 0.5)\n    ... ]\n\n    >>> result = get_transitions('a', transitions, 5000)\n\n    >>> result['a'] > result['b'] > result['c']\n    True\n    \"\"\"\n\n    graph = MarkovChainGraphUndirectedUnweighted()\n\n    for node1, node2, probability in transitions:\n        graph.add_transition_probability(node1, probability)\n\n    visited = Counter(graph.get_nodes())\n    node = start\n\n    for _ in range(steps):\n        node = graph.transition(node)\n        visited[node] += 1\n\n    return visited\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "fixed_code": "from __future__ import annotations\n\nfrom collections import Counter\nfrom random import random\n\n\nclass MarkovChainGraphUndirectedUnweighted:\n    \"\"\"\n    Undirected Unweighted Graph for running Markov Chain Algorithm\n    \"\"\"\n\n    def __init__(self):\n        self.connections = {}\n\n    def add_node(self, node: str) -> None:\n        self.connections[node] = {}\n\n    def add_transition_probability(\n        self, node1: str, node2: str, probability: float\n    ) -> None:\n        if node1 not in self.connections:\n            self.add_node(node1)\n        if node2 not in self.connections:\n            self.add_node(node2)\n        self.connections[node1][node2] = probability\n\n    def get_nodes(self) -> list[str]:\n        return list(self.connections)\n\n    def transition(self, node: str) -> str:\n        current_probability = 0\n        random_value = random()\n\n        for dest in self.connections[node]:\n            current_probability += self.connections[node][dest]\n            if current_probability > random_value:\n                return dest\n        return \"\"\n\n\ndef get_transitions(\n    start: str, transitions: list[tuple[str, str, float]], steps: int\n) -> dict[str, int]:\n    \"\"\"\n    Running Markov Chain algorithm and calculating the number of times each node is\n    visited\n\n    >>> transitions = [\n    ... ('a', 'a', 0.9),\n    ... ('a', 'b', 0.075),\n    ... ('a', 'c', 0.025),\n    ... ('b', 'a', 0.15),\n    ... ('b', 'b', 0.8),\n    ... ('b', 'c', 0.05),\n    ... ('c', 'a', 0.25),\n    ... ('c', 'b', 0.25),\n    ... ('c', 'c', 0.5)\n    ... ]\n\n    >>> result = get_transitions('a', transitions, 5000)\n\n    >>> result['a'] > result['b'] > result['c']\n    True\n    \"\"\"\n\n    graph = MarkovChainGraphUndirectedUnweighted()\n\n    for node1, node2, probability in transitions:\n        graph.add_transition_probability(node1, node2, probability)\n\n    visited = Counter(graph.get_nodes())\n    node = start\n\n    for _ in range(steps):\n        node = graph.transition(node)\n        visited[node] += 1\n\n    return visited\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "source_file": "10.py"
  },
  {
    "error_type": "syntax",
    "buggy_code": "\"\"\"\nhttps://en.wikipedia.org/wiki/Best-first_search#Greedy_BFS\n\"\"\"\n\nfrom __future__ import annotations\n\nPath = list[tuple[int, int]]\n\n# 0's are free path whereas 1's are obstacles\nTEST_GRIDS = [\n    [\n        [0, 0, 0, 0, 0, 0, 0,\n        [0, 1, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 1, 0, 0, 0, 0],\n        [1, 0, 1, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 1, 0, 0],\n    ],\n    [\n        [0, 0, 0, 1, 1, 0, 0],\n        [0, 0, 0, 0, 1, 0, 1],\n        [0, 0, 0, 1, 1, 0, 0],\n        [0, 1, 0, 0, 1, 0, 0],\n        [1, 0, 0, 1, 1, 0, 1],\n        [0, 0, 0, 0, 0, 0, 0],\n    ],\n    [\n        [0, 0, 1, 0, 0],\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 0, 1],\n        [1, 0, 0, 1, 1],\n        [0, 0, 0, 0, 0],\n    ],\n]\n\ndelta = ([-1, 0], [0, -1], [1, 0], [0, 1])  # up, left, down, right\n\n\nclass Node:\n    \"\"\"\n    >>> k = Node(0, 0, 4, 5, 0, None)\n    >>> k.calculate_heuristic()\n    9\n    >>> n = Node(1, 4, 3, 4, 2, None)\n    >>> n.calculate_heuristic()\n    2\n    >>> l = [k, n]\n    >>> n == l[0]\n    False\n    >>> l.sort()\n    >>> n == l[0]\n    True\n    \"\"\"\n\n    def __init__(\n        self,\n        pos_x: int,\n        pos_y: int,\n        goal_x: int,\n        goal_y: int,\n        g_cost: float,\n        parent: Node | None,\n    ):\n        self.pos_x = pos_x\n        self.pos_y = pos_y\n        self.pos = (pos_y, pos_x)\n        self.goal_x = goal_x\n        self.goal_y = goal_y\n        self.g_cost = g_cost\n        self.parent = parent\n        self.f_cost = self.calculate_heuristic()\n\n    def calculate_heuristic(self) -> float:\n        \"\"\"\n        The heuristic here is the Manhattan Distance\n        Could elaborate to offer more than one choice\n        \"\"\"\n        dx = abs(self.pos_x - self.goal_x)\n        dy = abs(self.pos_y - self.goal_y)\n        return dx + dy\n\n    def __lt__(self, other) -> bool:\n        return self.f_cost < other.f_cost\n\n    def __eq__(self, other) -> bool:\n        return self.pos == other.pos\n\n\nclass GreedyBestFirst:\n    \"\"\"\n    >>> grid = TEST_GRIDS[2]\n    >>> gbf = GreedyBestFirst(grid, (0, 0), (len(grid) - 1, len(grid[0]) - 1))\n    >>> [x.pos for x in gbf.get_successors(gbf.start)]\n    [(1, 0), (0, 1)]\n    >>> (gbf.start.pos_y + delta[3][0], gbf.start.pos_x + delta[3][1])\n    (0, 1)\n    >>> (gbf.start.pos_y + delta[2][0], gbf.start.pos_x + delta[2][1])\n    (1, 0)\n    >>> gbf.retrace_path(gbf.start)\n    [(0, 0)]\n    >>> gbf.search()  # doctest: +NORMALIZE_WHITESPACE\n    [(0, 0), (1, 0), (2, 0), (2, 1), (3, 1), (4, 1), (4, 2), (4, 3),\n     (4, 4)]\n    \"\"\"\n\n    def __init__(\n        self, grid: list[list[int]], start: tuple[int, int], goal: tuple[int, int]\n    ):\n        self.grid = grid\n        self.start = Node(start[1], start[0], goal[1], goal[0], 0, None)\n        self.target = Node(goal[1], goal[0], goal[1], goal[0], 99999, None)\n\n        self.open_nodes = [self.start]\n        self.closed_nodes: list[Node] = []\n\n        self.reached = False\n\n    def search(self) -> Path | None:\n        \"\"\"\n        Search for the path,\n        if a path is not found, only the starting position is returned\n        \"\"\"\n        while self.open_nodes:\n            # Open Nodes are sorted using __lt__\n            self.open_nodes.sort()\n            current_node = self.open_nodes.pop(0)\n\n            if current_node.pos == self.target.pos:\n                self.reached = True\n                return self.retrace_path(current_node)\n\n            self.closed_nodes.append(current_node)\n            successors = self.get_successors(current_node)\n\n            for child_node in successors:\n                if child_node in self.closed_nodes:\n                    continue\n\n                if child_node not in self.open_nodes:\n                    self.open_nodes.append(child_node)\n\n        if not self.reached:\n            return [self.start.pos]\n        return None\n\n    def get_successors(self, parent: Node) -> list[Node]:\n        \"\"\"\n        Returns a list of successors (both in the grid and free spaces)\n        \"\"\"\n        return [\n            Node(\n                pos_x,\n                pos_y,\n                self.target.pos_x,\n                self.target.pos_y,\n                parent.g_cost + 1,\n                parent,\n            )\n            for action in delta\n            if (\n                0 <= (pos_x := parent.pos_x + action[1]) < len(self.grid[0])\n                and 0 <= (pos_y := parent.pos_y + action[0]) < len(self.grid)\n                and self.grid[pos_y][pos_x] == 0\n            )\n        ]\n\n    def retrace_path(self, node: Node | None) -> Path:\n        \"\"\"\n        Retrace the path from parents to parents until start node\n        \"\"\"\n        current_node = node\n        path = []\n        while current_node is not None:\n            path.append((current_node.pos_y, current_node.pos_x))\n            current_node = current_node.parent\n        path.reverse()\n        return path\n\n\nif __name__ == \"__main__\":\n    for idx, grid in enumerate(TEST_GRIDS):\n        print(f\"==grid-{idx + 1}==\")\n\n        init = (0, 0)\n        goal = (len(grid) - 1, len(grid[0]) - 1)\n        for elem in grid:\n            print(elem)\n\n        print(\"------\")\n\n        greedy_bf = GreedyBestFirst(grid, init, goal)\n        path = greedy_bf.search()\n        if path:\n            for pos_x, pos_y in path:\n                grid[pos_x][pos_y] = 2\n\n            for elem in grid:\n                print(elem)",
    "fixed_code": "\"\"\"\nhttps://en.wikipedia.org/wiki/Best-first_search#Greedy_BFS\n\"\"\"\n\nfrom __future__ import annotations\n\nPath = list[tuple[int, int]]\n\n# 0's are free path whereas 1's are obstacles\nTEST_GRIDS = [\n    [\n        [0, 0, 0, 0, 0, 0, 0],\n        [0, 1, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 1, 0, 0, 0, 0],\n        [1, 0, 1, 0, 0, 0, 0],\n        [0, 0, 0, 0, 0, 0, 0],\n        [0, 0, 0, 0, 1, 0, 0],\n    ],\n    [\n        [0, 0, 0, 1, 1, 0, 0],\n        [0, 0, 0, 0, 1, 0, 1],\n        [0, 0, 0, 1, 1, 0, 0],\n        [0, 1, 0, 0, 1, 0, 0],\n        [1, 0, 0, 1, 1, 0, 1],\n        [0, 0, 0, 0, 0, 0, 0],\n    ],\n    [\n        [0, 0, 1, 0, 0],\n        [0, 1, 0, 0, 0],\n        [0, 0, 1, 0, 1],\n        [1, 0, 0, 1, 1],\n        [0, 0, 0, 0, 0],\n    ],\n]\n\ndelta = ([-1, 0], [0, -1], [1, 0], [0, 1])  # up, left, down, right\n\n\nclass Node:\n    \"\"\"\n    >>> k = Node(0, 0, 4, 5, 0, None)\n    >>> k.calculate_heuristic()\n    9\n    >>> n = Node(1, 4, 3, 4, 2, None)\n    >>> n.calculate_heuristic()\n    2\n    >>> l = [k, n]\n    >>> n == l[0]\n    False\n    >>> l.sort()\n    >>> n == l[0]\n    True\n    \"\"\"\n\n    def __init__(\n        self,\n        pos_x: int,\n        pos_y: int,\n        goal_x: int,\n        goal_y: int,\n        g_cost: float,\n        parent: Node | None,\n    ):\n        self.pos_x = pos_x\n        self.pos_y = pos_y\n        self.pos = (pos_y, pos_x)\n        self.goal_x = goal_x\n        self.goal_y = goal_y\n        self.g_cost = g_cost\n        self.parent = parent\n        self.f_cost = self.calculate_heuristic()\n\n    def calculate_heuristic(self) -> float:\n        \"\"\"\n        The heuristic here is the Manhattan Distance\n        Could elaborate to offer more than one choice\n        \"\"\"\n        dx = abs(self.pos_x - self.goal_x)\n        dy = abs(self.pos_y - self.goal_y)\n        return dx + dy\n\n    def __lt__(self, other) -> bool:\n        return self.f_cost < other.f_cost\n\n    def __eq__(self, other) -> bool:\n        return self.pos == other.pos\n\n\nclass GreedyBestFirst:\n    \"\"\"\n    >>> grid = TEST_GRIDS[2]\n    >>> gbf = GreedyBestFirst(grid, (0, 0), (len(grid) - 1, len(grid[0]) - 1))\n    >>> [x.pos for x in gbf.get_successors(gbf.start)]\n    [(1, 0), (0, 1)]\n    >>> (gbf.start.pos_y + delta[3][0], gbf.start.pos_x + delta[3][1])\n    (0, 1)\n    >>> (gbf.start.pos_y + delta[2][0], gbf.start.pos_x + delta[2][1])\n    (1, 0)\n    >>> gbf.retrace_path(gbf.start)\n    [(0, 0)]\n    >>> gbf.search()  # doctest: +NORMALIZE_WHITESPACE\n    [(0, 0), (1, 0), (2, 0), (2, 1), (3, 1), (4, 1), (4, 2), (4, 3),\n     (4, 4)]\n    \"\"\"\n\n    def __init__(\n        self, grid: list[list[int]], start: tuple[int, int], goal: tuple[int, int]\n    ):\n        self.grid = grid\n        self.start = Node(start[1], start[0], goal[1], goal[0], 0, None)\n        self.target = Node(goal[1], goal[0], goal[1], goal[0], 99999, None)\n\n        self.open_nodes = [self.start]\n        self.closed_nodes: list[Node] = []\n\n        self.reached = False\n\n    def search(self) -> Path | None:\n        \"\"\"\n        Search for the path,\n        if a path is not found, only the starting position is returned\n        \"\"\"\n        while self.open_nodes:\n            # Open Nodes are sorted using __lt__\n            self.open_nodes.sort()\n            current_node = self.open_nodes.pop(0)\n\n            if current_node.pos == self.target.pos:\n                self.reached = True\n                return self.retrace_path(current_node)\n\n            self.closed_nodes.append(current_node)\n            successors = self.get_successors(current_node)\n\n            for child_node in successors:\n                if child_node in self.closed_nodes:\n                    continue\n\n                if child_node not in self.open_nodes:\n                    self.open_nodes.append(child_node)\n\n        if not self.reached:\n            return [self.start.pos]\n        return None\n\n    def get_successors(self, parent: Node) -> list[Node]:\n        \"\"\"\n        Returns a list of successors (both in the grid and free spaces)\n        \"\"\"\n        return [\n            Node(\n                pos_x,\n                pos_y,\n                self.target.pos_x,\n                self.target.pos_y,\n                parent.g_cost + 1,\n                parent,\n            )\n            for action in delta\n            if (\n                0 <= (pos_x := parent.pos_x + action[1]) < len(self.grid[0])\n                and 0 <= (pos_y := parent.pos_y + action[0]) < len(self.grid)\n                and self.grid[pos_y][pos_x] == 0\n            )\n        ]\n\n    def retrace_path(self, node: Node | None) -> Path:\n        \"\"\"\n        Retrace the path from parents to parents until start node\n        \"\"\"\n        current_node = node\n        path = []\n        while current_node is not None:\n            path.append((current_node.pos_y, current_node.pos_x))\n            current_node = current_node.parent\n        path.reverse()\n        return path\n\n\nif __name__ == \"__main__\":\n    for idx, grid in enumerate(TEST_GRIDS):\n        print(f\"==grid-{idx + 1}==\")\n\n        init = (0, 0)\n        goal = (len(grid) - 1, len(grid[0]) - 1)\n        for elem in grid:\n            print(elem)\n\n        print(\"------\")\n\n        greedy_bf = GreedyBestFirst(grid, init, goal)\n        path = greedy_bf.search()\n        if path:\n            for pos_x, pos_y in path:\n                grid[pos_x][pos_y] = 2\n\n            for elem in grid:\n                print(elem)",
    "source_file": "26.py"
  },
  {
    "error_type": "syntax",
    "buggy_code": "\"\"\"\nhttps://en.wikipedia.org/wiki/Floor_and_ceiling_functions\n\"\"\"\n\n\ndef floor(x: float) -> int:\n    \"\"\"\n    Return the floor of x as an Integral.\n    :param x: the number\n    :return: the largest integer <= x.\n    >>> import math\n    >>> all(floor(n) == math.floor(n) for n\n    ...     in (1, -1, 0, -0, 1.1, -1.1, 1.0, -1.0, 1_000_000_000))\n    True\n    \"\"\"\n    return int(x) if x - int(x) >= 0 else int(x) - 1\n\n\nif __name__ == \"__main__\":\nimport doctest\n\ndoctest.testmod()",
    "fixed_code": "\"\"\"\nhttps://en.wikipedia.org/wiki/Floor_and_ceiling_functions\n\"\"\"\n\n\ndef floor(x: float) -> int:\n    \"\"\"\n    Return the floor of x as an Integral.\n    :param x: the number\n    :return: the largest integer <= x.\n    >>> import math\n    >>> all(floor(n) == math.floor(n) for n\n    ...     in (1, -1, 0, -0, 1.1, -1.1, 1.0, -1.0, 1_000_000_000))\n    True\n    \"\"\"\n    return int(x) if x - int(x) >= 0 else int(x) - 1\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "source_file": "24.py"
  },
  {
    "error_type": "syntax",
    "buggy_code": "\"\"\"\nA hexagonal number sequence is a sequence of figurate numbers\nwhere the nth hexagonal number h\u2099 is the number of distinct dots\nin a pattern of dots consisting of the outlines of regular\nhexagons with sides up to n dots, when the hexagons are overlaid\nso that they share one vertex.\n\n    Calculates the hexagonal numbers sequence with a formula\n        h\u2099 = n(2n-1)\n        where:\n        h\u2099 --> is nth element of the sequence\n        n --> is the number of element in the sequence\n        reference-->\"Hexagonal number\" Wikipedia\n        <https://en.wikipedia.org/wiki/Hexagonal_number>\n\"\"\"\n\n\ndef hexagonal_numbers(length: int) -> list[int]\n    \"\"\"\n    :param len: max number of elements\n    :type len: int\n    :return: Hexagonal numbers as a list\n\n    Tests:\n    >>> hexagonal_numbers(10)\n    [0, 1, 6, 15, 28, 45, 66, 91, 120, 153]\n    >>> hexagonal_numbers(5)\n    [0, 1, 6, 15, 28]\n    >>> hexagonal_numbers(0)\n    Traceback (most recent call last):\n      ...\n    ValueError: Length must be a positive integer.\n    \"\"\"\n\n    if length <== 0 or not isinstance(length, int):\n        raise ValueError \"Length must be a positive integer.\")\n    return [n * (2 * n - 1) for n in range(length)]\n\n\nif __name__ == \"__main__\":\n    print(hexagonal_numbers(length=5))\n    print(hexagonal_numbers(length=10))",
    "fixed_code": "\"\"\"\nA hexagonal number sequence is a sequence of figurate numbers\nwhere the nth hexagonal number h\u2099 is the number of distinct dots\nin a pattern of dots consisting of the outlines of regular\nhexagons with sides up to n dots, when the hexagons are overlaid\nso that they share one vertex.\n\n    Calculates the hexagonal numbers sequence with a formula\n        h\u2099 = n(2n-1)\n        where:\n        h\u2099 --> is nth element of the sequence\n        n --> is the number of element in the sequence\n        reference-->\"Hexagonal number\" Wikipedia\n        <https://en.wikipedia.org/wiki/Hexagonal_number>\n\"\"\"\n\n\ndef hexagonal_numbers(length: int) -> list[int]:\n    \"\"\"\n    :param len: max number of elements\n    :type len: int\n    :return: Hexagonal numbers as a list\n\n    Tests:\n    >>> hexagonal_numbers(10)\n    [0, 1, 6, 15, 28, 45, 66, 91, 120, 153]\n    >>> hexagonal_numbers(5)\n    [0, 1, 6, 15, 28]\n    >>> hexagonal_numbers(0)\n    Traceback (most recent call last):\n      ...\n    ValueError: Length must be a positive integer.\n    \"\"\"\n\n    if length <= 0 or not isinstance(length, int):\n        raise ValueError(\"Length must be a positive integer.\")\n    return [n * (2 * n - 1) for n in range(length)]\n\n\nif __name__ == \"__main__\":\n    print(hexagonal_numbers(length=5))\n    print(hexagonal_numbers(length=10))",
    "source_file": "9.py"
  },
  {
    "error_type": "syntax",
    "buggy_code": "\"\"\"\nChinese Remainder Theorem:\nGCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n\nIf GCD(a,b) = 1, then for any remainder ra modulo a and any remainder rb modulo b\nthere exists integer n, such that n = ra (mod a) and n = ra(mod b).  If n1 and n2 are\ntwo such integers, then n1=n2(mod ab)\n\nAlgorithm :\n\n1. Use extended euclid algorithm to find x,y such that a*x + b*y = 1\n2. Take n = ra*by + rb*ax\n\"\"\"\n\nfrom __future__ import annotations\n\n\n# Extended Euclid\ndef extended_euclid(a: int, b: int -> tuple[int, int]:\n    \"\"\"\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)\n\n\n# Uses ExtendedEuclid to find inverses\ndef chinese_remainder_theorem(n1: int, r1: int, n2: int, r2: int) -> int:\n    \"\"\"\n    >>> chinese_remainder_theorem(5,1,7,3)\n    31\n\n    Explanation : 31 is the smallest number such that\n                (i)  When we divide it by 5, we get remainder 1\n                (ii) When we divide it by 7, we get remainder 3\n\n    >>> chinese_remainder_theorem(6,1,4,3)\n    14\n\n    \"\"\"\n    (x, y) = extended_euclid(n1, n2)\n    m = n1 * n2\n    n = r2 * x * n1 + r1 * y * n2\n    return (n % m + m) % m\n\n\n# ----------SAME SOLUTION USING InvertModulo instead ExtendedEuclid----------------\n\n\n# This function find the inverses of a i.e., a^(-1)\ndef invert_modulo(a: int, n: int) -> int:\n    \"\"\"\n    >>> invert_modulo(2, 5)\n    3\n\n    >>> invert_modulo(8,7)\n    1\n\n    \"\"\"\n    (b, x) = extended_euclid(a, n)\n    if b < 0:\n        b = (b % n + n) % n\n    return b\n\n\n$ Same a above using InvertingModulo\ndef chinese_remainder_theorem2(n1: int, r1: int, n2: int, r2: int) -> int:\n    \"\"\"\n    >>> chinese_remainder_theorem2(5,1,7,3)\n    31\n\n    >>> chinese_remainder_theorem2(6,1,4,3)\n    14\n\n    \"\"\"\n    x, y = invert_modulo(n1, n2), invert_modulo(n2, n1)\n    m = n1 * n2\n    n = r2 * x * n1 + r1 * y * n2\n    return (n % m + m) % m\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod(name=\"chinese_remainder_theorem\", verbose=True)\n    testmod(name=\"chinese_remainder_theorem2\", verbose=True)\n    testmod(name=\"invert_modulo\", verbose=True)\n    testmod(name=\"extended_euclid\", verbose=True)",
    "fixed_code": "\"\"\"\nChinese Remainder Theorem:\nGCD ( Greatest Common Divisor ) or HCF ( Highest Common Factor )\n\nIf GCD(a,b) = 1, then for any remainder ra modulo a and any remainder rb modulo b\nthere exists integer n, such that n = ra (mod a) and n = ra(mod b).  If n1 and n2 are\ntwo such integers, then n1=n2(mod ab)\n\nAlgorithm :\n\n1. Use extended euclid algorithm to find x,y such that a*x + b*y = 1\n2. Take n = ra*by + rb*ax\n\"\"\"\n\nfrom __future__ import annotations\n\n\n# Extended Euclid\ndef extended_euclid(a: int, b: int) -> tuple[int, int]:\n    \"\"\"\n    >>> extended_euclid(10, 6)\n    (-1, 2)\n\n    >>> extended_euclid(7, 5)\n    (-2, 3)\n\n    \"\"\"\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)\n\n\n# Uses ExtendedEuclid to find inverses\ndef chinese_remainder_theorem(n1: int, r1: int, n2: int, r2: int) -> int:\n    \"\"\"\n    >>> chinese_remainder_theorem(5,1,7,3)\n    31\n\n    Explanation : 31 is the smallest number such that\n                (i)  When we divide it by 5, we get remainder 1\n                (ii) When we divide it by 7, we get remainder 3\n\n    >>> chinese_remainder_theorem(6,1,4,3)\n    14\n\n    \"\"\"\n    (x, y) = extended_euclid(n1, n2)\n    m = n1 * n2\n    n = r2 * x * n1 + r1 * y * n2\n    return (n % m + m) % m\n\n\n# ----------SAME SOLUTION USING InvertModulo instead ExtendedEuclid----------------\n\n\n# This function find the inverses of a i.e., a^(-1)\ndef invert_modulo(a: int, n: int) -> int:\n    \"\"\"\n    >>> invert_modulo(2, 5)\n    3\n\n    >>> invert_modulo(8,7)\n    1\n\n    \"\"\"\n    (b, x) = extended_euclid(a, n)\n    if b < 0:\n        b = (b % n + n) % n\n    return b\n\n\n# Same a above using InvertingModulo\ndef chinese_remainder_theorem2(n1: int, r1: int, n2: int, r2: int) -> int:\n    \"\"\"\n    >>> chinese_remainder_theorem2(5,1,7,3)\n    31\n\n    >>> chinese_remainder_theorem2(6,1,4,3)\n    14\n\n    \"\"\"\n    x, y = invert_modulo(n1, n2), invert_modulo(n2, n1)\n    m = n1 * n2\n    n = r2 * x * n1 + r1 * y * n2\n    return (n % m + m) % m\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod(name=\"chinese_remainder_theorem\", verbose=True)\n    testmod(name=\"chinese_remainder_theorem2\", verbose=True)\n    testmod(name=\"invert_modulo\", verbose=True)\n    testmod(name=\"extended_euclid\", verbose=True)",
    "source_file": "5.py"
  },
  {
    "error_type": "syntax",
    "buggy_code": "#!/usr/bin/env python3\n\n\"\"\"\nPython program to translate to and from Morse code.\n\nhttps://en.wikipedia.org/wiki/Morse_code\n\"\"\"\n\n# fmt: off\nMORSE_CODE_DICT = {\n    \"A\": \".-\", \"B\": \"-...\", \"C\": \"-.-.\", \"D\": \"-..\", \"E\": \".\", \"F\": \"..-.\", \"G\": \"--.\",\n    \"H\": \"....\", \"I\": \"..\", \"J\": \".---\", \"K\": \"-.-\", \"L\": \".-..\", \"M\": \"--\", \"N\": \"-.\",\n    \"O\": \"---\", \"P\": \".--.\", \"Q\": \"--.-\", \"R\": \".-.\", \"S\": \"...\", \"T\": \"-\", \"U\": \"..-\",\n    \"V\": \"...-\", \"W\": \".--\", \"X\": \"-..-\", \"Y\": \"-.--\", \"Z\": \"--..\", \"1\": \".----\",\n    \"2\": \"..---\", \"3\": \"...--\", \"4\": \"....-\", \"5\": \".....\", \"6\": \"-....\", \"7\": \"--...\",\n    \"8\": \"---..\", \"9\": \"----.\", \"0\": \"-----\", \"&\": \".-...\", \"@\": \".--.-.\",\n    \":\": \"---...\", \",\": \"--..--\", \".\": \".-.-.-\", \"'\": \".----.\", '\"': \".-..-.\",\n    \"?\": \"..--..\", \"/\": \"-..-.\", \"=\": \"-...-\", \"+\": \".-.-.\", \"-\": \"-....-\",\n    \"(\": \"-.--.\", \")\": \"-.--.-\", \"!\": \"-.-.--\", \" \": \"/\"\n}  # Exclamation mark is not in ITU-R recommendation\n# fmt: on\nREVERSE_DICT = {value: key for key, value in MORSE_CODE_DICT.items()}\n\n\ndef encrypt(message: str) -> str:\n    \"\"\"\n    >>> encrypt(\"Sos!\")\n    '... --- ... -.-.--'\n    >>> encrypt(\"SOS!\") == encrypt(\"sos!\")\n    True\n    \"\"\"\n    return \" \".join(MORSE_CODE_DICT[char] for char in message.upper())\n\n\ndef decrypt(message: str) -> str:\n    \"\"\"\n    >>> decrypt('... --- ... -.-.--')\n    'SOS!'\n    \"\"\"\n    return \".join(REVERSE_DICT[char] for char in message.split())\n\n\ndef main() -> None:\n    \"\"\"\n    >>> s = \"\".join(MORSE_CODE_DICT)\n    >>> decrypt(encrypt(s)) == s\n    True\n    \"\"\"\n    message = \"Morse code here!\"\n    print(message)\n    message = encrypt(message)\n    print(message)\n    message = decrypt(message)\n    print(message)\n\n\nif __name__ == \"__main__\":\n    main()",
    "fixed_code": "#!/usr/bin/env python3\n\n\"\"\"\nPython program to translate to and from Morse code.\n\nhttps://en.wikipedia.org/wiki/Morse_code\n\"\"\"\n\n# fmt: off\nMORSE_CODE_DICT = {\n    \"A\": \".-\", \"B\": \"-...\", \"C\": \"-.-.\", \"D\": \"-..\", \"E\": \".\", \"F\": \"..-.\", \"G\": \"--.\",\n    \"H\": \"....\", \"I\": \"..\", \"J\": \".---\", \"K\": \"-.-\", \"L\": \".-..\", \"M\": \"--\", \"N\": \"-.\",\n    \"O\": \"---\", \"P\": \".--.\", \"Q\": \"--.-\", \"R\": \".-.\", \"S\": \"...\", \"T\": \"-\", \"U\": \"..-\",\n    \"V\": \"...-\", \"W\": \".--\", \"X\": \"-..-\", \"Y\": \"-.--\", \"Z\": \"--..\", \"1\": \".----\",\n    \"2\": \"..---\", \"3\": \"...--\", \"4\": \"....-\", \"5\": \".....\", \"6\": \"-....\", \"7\": \"--...\",\n    \"8\": \"---..\", \"9\": \"----.\", \"0\": \"-----\", \"&\": \".-...\", \"@\": \".--.-.\",\n    \":\": \"---...\", \",\": \"--..--\", \".\": \".-.-.-\", \"'\": \".----.\", '\"': \".-..-.\",\n    \"?\": \"..--..\", \"/\": \"-..-.\", \"=\": \"-...-\", \"+\": \".-.-.\", \"-\": \"-....-\",\n    \"(\": \"-.--.\", \")\": \"-.--.-\", \"!\": \"-.-.--\", \" \": \"/\"\n}  # Exclamation mark is not in ITU-R recommendation\n# fmt: on\nREVERSE_DICT = {value: key for key, value in MORSE_CODE_DICT.items()}\n\n\ndef encrypt(message: str) -> str:\n    \"\"\"\n    >>> encrypt(\"Sos!\")\n    '... --- ... -.-.--'\n    >>> encrypt(\"SOS!\") == encrypt(\"sos!\")\n    True\n    \"\"\"\n    return \" \".join(MORSE_CODE_DICT[char] for char in message.upper())\n\n\ndef decrypt(message: str) -> str:\n    \"\"\"\n    >>> decrypt('... --- ... -.-.--')\n    'SOS!'\n    \"\"\"\n    return \"\".join(REVERSE_DICT[char] for char in message.split())\n\n\ndef main() -> None:\n    \"\"\"\n    >>> s = \"\".join(MORSE_CODE_DICT)\n    >>> decrypt(encrypt(s)) == s\n    True\n    \"\"\"\n    message = \"Morse code here!\"\n    print(message)\n    message = encrypt(message)\n    print(message)\n    message = decrypt(message)\n    print(message)\n\n\nif __name__ == \"__main__\":\n    main()",
    "source_file": "30.py"
  }
]