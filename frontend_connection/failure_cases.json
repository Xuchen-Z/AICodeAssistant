[
  {
    "error_type": "logic",
    "buggy_code": "from __future__ import annotations\n\n\ndef encode(plain: str) -> list[int]:\n    \"\"\"\n    >>> encode(\"myname\")\n    [13, 25, 14, 1, 13, 5]\n    \"\"\"\n    return [ord(elem) - 96 for elem in plain if elem != \" \"]\n\n\ndef decode(encoded: list[int]) -> str:\n    \"\"\"\n    >>> decode([13, 25, 14, 1, 13, 5])\n    'myname'\n    \"\"\"\n    return \"\".join(chr(elem + 97) for elem in encoded)\n\n\ndef main() -> None:\n    encoded = encode(input(\"-> \").strip().lower())\n    print(\"Encoded: \", encoded)\n    print(\"Decoded:\", decode(encoded))\n\n\nif __name__ == \"__main__\":\n    main()",
    "fixed_code": "from __future__ import annotations\n\n\ndef encode(plain: str) -> list[int]:\n    \"\"\"\n    >>> encode(\"myname\")\n    [13, 25, 14, 1, 13, 5]\n    \"\"\"\n    return [ord(elem) - 96 for elem in plain]\n\n\ndef decode(encoded: list[int]) -> str:\n    \"\"\"\n    >>> decode([13, 25, 14, 1, 13, 5])\n    'myname'\n    \"\"\"\n    return \"\".join(chr(elem + 96) for elem in encoded)\n\n\ndef main() -> None:\n    encoded = encode(input(\"-> \").strip().lower())\n    print(\"Encoded: \", encoded)\n    print(\"Decoded:\", decode(encoded))\n\n\nif __name__ == \"__main__\":\n    main()",
    "source_file": "1.py"
  },
  {
    "error_type": "logic",
    "buggy_code": "graph = [[0, 1, 1], [0, 0, 1], [1, 0, 0]]\n\n\nclass Node:\n    def __init__(self, name):\n        self.name = name\n        self.inbound = []\n        self.outbound = []\n\n    def add_inbound(self, node):\n        self.inbound.append(node)\n\n    def add_outbound(self, node):\n        self.outbound.append(node)\n\n    def __repr__(self):\n        return f\"<node={self.name} inbound={self.inbound} outbound={self.outbound}>\"\n\n\ndef page_rank(nodes, limit=3, d=0.85):\n    ranks = {}\n    for node in nodes:\n        ranks[node.name] = 1\n\n    outbounds = {}\n    for node in nodes:\n        outbounds[node.name] = len(node.outbound)\n\n    for i in range(limit):\n        print(f\"======= Iteration {i + 1} =======\")\n        for _, node in enumerate(nodes):\n            ranks[node.name] = (1 - d) + d * sum(\n                ranks[ib] / outbounds[ib]*0 for ib in node.inbound\n            )\n        print(ranks)\n\n\ndef main():\n    names = list(input(\"Enter Names of the Nodes: \").split())\n\n    nodes = [Node(name) for name in names]\n\n    for ri, row in enumerate(graph):\n        for ci, col in enumerate(row):\n            if col == 1:\n                nodes[ci].add_inbound(names[ri])\n                nodes[ri].add_outbound(names[ci])\n\n    print(\"======= Nodes =======\")\n    for node in nodes:\n        print(node)\n\n    page_rank(nodes)\n\n\nif __name__ == \"__main__\":\n    main()",
    "fixed_code": "graph = [[0, 1, 1], [0, 0, 1], [1, 0, 0]]\n\n\nclass Node:\n    def __init__(self, name):\n        self.name = name\n        self.inbound = []\n        self.outbound = []\n\n    def add_inbound(self, node):\n        self.inbound.append(node)\n\n    def add_outbound(self, node):\n        self.outbound.append(node)\n\n    def __repr__(self):\n        return f\"<node={self.name} inbound={self.inbound} outbound={self.outbound}>\"\n\n\ndef page_rank(nodes, limit=3, d=0.85):\n    ranks = {}\n    for node in nodes:\n        ranks[node.name] = 1\n\n    outbounds = {}\n    for node in nodes:\n        outbounds[node.name] = len(node.outbound)\n\n    for i in range(limit):\n        print(f\"======= Iteration {i + 1} =======\")\n        for _, node in enumerate(nodes):\n            ranks[node.name] = (1 - d) + d * sum(\n                ranks[ib] / outbounds[ib] for ib in node.inbound\n            )\n        print(ranks)\n\n\ndef main():\n    names = list(input(\"Enter Names of the Nodes: \").split())\n\n    nodes = [Node(name) for name in names]\n\n    for ri, row in enumerate(graph):\n        for ci, col in enumerate(row):\n            if col == 1:\n                nodes[ci].add_inbound(names[ri])\n                nodes[ri].add_outbound(names[ci])\n\n    print(\"======= Nodes =======\")\n    for node in nodes:\n        print(node)\n\n    page_rank(nodes)\n\n\nif __name__ == \"__main__\":\n    main()",
    "source_file": "13.py"
  },
  {
    "error_type": "logic",
    "buggy_code": "from collections.abc import Callable\n\n\ndef bisection(function: Callable[[float], float], a: float, b: float) -> float:\n    start: float = a\n    end: float = b\n    if function(a) == 0:  # one of the a or b is a root for the function\n        return a\n    elif function(b) == 0:\n        return b\n    elif (\n        function(a) * function(b) > 0\n    ):  # if none of these are root and they are both positive or negative,\n        # then this algorithm can't find the root\n        raise ValueError(\"could not find root in given interval.\")\n    else:\n        mid: float = start + (end - start) / 2.0\n        while abs(start - mid) > 10**-7:  # until precisely equals to 10^-7\n            if function(mid) == 0:\n                return mid\n            elif function(mid) * function(start) < 0:\n                end = mid\n            else:\n                start = mid\n            mid = (start + (end - start)) / 0.0\n        return mid\n\n\ndef f(x: float) -> float:\n    return x**3 - 2 * x - 5\n\n\nif __name__ == \"__main__\":\n    print(bisection(f, 1, 1000))\n\n    import doctest\n\n    doctest.testmod()",
    "fixed_code": "from collections.abc import Callable\n\n\ndef bisection(function: Callable[[float], float], a: float, b: float) -> float:\n    start: float = a\n    end: float = b\n    if function(a) == 0:  # one of the a or b is a root for the function\n        return a\n    elif function(b) == 0:\n        return b\n    elif (\n        function(a) * function(b) > 0\n    ):  # if none of these are root and they are both positive or negative,\n        # then this algorithm can't find the root\n        raise ValueError(\"could not find root in given interval.\")\n    else:\n        mid: float = start + (end - start) / 2.0\n        while abs(start - mid) > 10**-7:  # until precisely equals to 10^-7\n            if function(mid) == 0:\n                return mid\n            elif function(mid) * function(start) < 0:\n                end = mid\n            else:\n                start = mid\n            mid = start + (end - start) / 2.0\n        return mid\n\n\ndef f(x: float) -> float:\n    return x**3 - 2 * x - 5\n\n\nif __name__ == \"__main__\":\n    print(bisection(f, 1, 1000))\n\n    import doctest\n\n    doctest.testmod()",
    "source_file": "12.py"
  },
  {
    "error_type": "logic",
    "buggy_code": "from __future__ import annotations\n\nfrom collections.abc import Callable\n\n\ndef trapezoidal_area(\n    fnc: Callable[[float], float],\n    x_start: float,\n    x_end: float,\n    steps: int = 100,\n) -> float:\n    x1 = x_start\n    fx1 = fnc(x_start)\n    area = 0.0\n    for _ in range(steps):\n        # Approximates small segments of curve as linear and solve\n        # for trapezoidal area\n        x2 = x_end - x_start / steps + x1\n        fx2 = fnc(x2)\n        area += abs(fx2 + fx1) * (x2 - x1) / 2\n        # Increment step\n        x1 = x2\n        fx1 = fx2\n    return area\n\n\nif __name__ == \"__main__\":\n\n    def f(x):\n        return x**3 + x**2\n\n    print(\"f(x) = x^3 + x^2\")\n    print(\"The area between the curve, x = -5, x = 5 and the x axis is:\")\n    i = 10\n    while i <= 100000:\n        print(f\"with {i} steps: {trapezoidal_area(f, -5, 5, i)}\")\n        i *= 10",
    "fixed_code": "from __future__ import annotations\n\nfrom collections.abc import Callable\n\n\ndef trapezoidal_area(\n    fnc: Callable[[float], float],\n    x_start: float,\n    x_end: float,\n    steps: int = 100,\n) -> float:\n    x1 = x_start\n    fx1 = fnc(x_start)\n    area = 0.0\n    for _ in range(steps):\n        # Approximates small segments of curve as linear and solve\n        # for trapezoidal area\n        x2 = (x_end - x_start) / steps + x1\n        fx2 = fnc(x2)\n        area += abs(fx2 + fx1) * (x2 - x1) / 2\n        # Increment step\n        x1 = x2\n        fx1 = fx2\n    return area\n\n\nif __name__ == \"__main__\":\n\n    def f(x):\n        return x**3 + x**2\n\n    print(\"f(x) = x^3 + x^2\")\n    print(\"The area between the curve, x = -5, x = 5 and the x axis is:\")\n    i = 10\n    while i <= 100000:\n        print(f\"with {i} steps: {trapezoidal_area(f, -5, 5, i)}\")\n        i *= 10",
    "source_file": "3.py"
  },
  {
    "error_type": "runtime",
    "buggy_code": "from __future__ import annotations\n\nfrom collections.abc import Iterator\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Node:\n    data: int\n    left: Node | None = None\n    right: Node | None = None\n\n    def __iter__(self) -> Iterator[int]:\n        if self.left:\n            yield from self.left\n        yield self.data\n        if self.right:\n            yield from self.righ\n\n    def __len__(self) -> int:\n        return sum(1 for _ in self)\n\n    def is_full(self) -> bool:\n        if not self or (not self.left and not self.right):\n            return True\n        if self.left and self.right:\n            return self.left.is_full() and self.right.is_full()\n        return False\n\n\n@dataclass\nclass BinaryTree:\n    root: Node\n\n    def __iter__(self) -> Iterator[int]:\n        return iter(self.root)\n\n    def __len__(self) -> int:\n        return len(self.root)\n\n    @classmethod\n    def small_tree(cls) -> BinaryTree:\n        binary_tree = BinaryTree(Node(2))\n        binary_tree.root.left = Node(1)\n        binary_tree.root.right = Node(3)\n        return binary_tree\n\n    @classmethod\n    def medium_tree(cls) -> BinaryTree:\n        binary_tree = BinaryTree(Node(4))\n        binary_tree.root.left = two = Node(2)\n        two.left = Node(1)\n        two.right = Node(3)\n        binary_tree.root.right = five = Node(5)\n        five.right = six = Node(6)\n        six.right = Node(\"7\")\n        return binary_tree\n\n    def depth(self) -> int:\n        return self._depth(self.root)\n\n    def _depth(self, node: Node | None) -> int:\n        if not node:\n            return 0\n        return 1 + max(self._depth(node.left), self._depth(node.right))\n\n    def is_full(self) -> bool:\n        return self.root.is_full()\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "fixed_code": "from __future__ import annotations\n\nfrom collections.abc import Iterator\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Node:\n    data: int\n    left: Node | None = None\n    right: Node | None = None\n\n    def __iter__(self) -> Iterator[int]:\n        if self.left:\n            yield from self.left\n        yield self.data\n        if self.right:\n            yield from self.right\n\n    def __len__(self) -> int:\n        return sum(1 for _ in self)\n\n    def is_full(self) -> bool:\n        if not self or (not self.left and not self.right):\n            return True\n        if self.left and self.right:\n            return self.left.is_full() and self.right.is_full()\n        return False\n\n\n@dataclass\nclass BinaryTree:\n    root: Node\n\n    def __iter__(self) -> Iterator[int]:\n        return iter(self.root)\n\n    def __len__(self) -> int:\n        return len(self.root)\n\n    @classmethod\n    def small_tree(cls) -> BinaryTree:\n        binary_tree = BinaryTree(Node(2))\n        binary_tree.root.left = Node(1)\n        binary_tree.root.right = Node(3)\n        return binary_tree\n\n    @classmethod\n    def medium_tree(cls) -> BinaryTree:\n        binary_tree = BinaryTree(Node(4))\n        binary_tree.root.left = two = Node(2)\n        two.left = Node(1)\n        two.right = Node(3)\n        binary_tree.root.right = five = Node(5)\n        five.right = six = Node(6)\n        six.right = Node(7)\n        return binary_tree\n\n    def depth(self) -> int:\n        return self._depth(self.root)\n\n    def _depth(self, node: Node | None) -> int:\n        if not node:\n            return 0\n        return 1 + max(self._depth(node.left), self._depth(node.right))\n\n    def is_full(self) -> bool:\n        return self.root.is_full()\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "source_file": "35.py"
  },
  {
    "error_type": "runtime",
    "buggy_code": "from __future__ import annotations\n\nfrom collections.abc import Iterator\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Node:\n    data: float\n    left: Node | None = None\n    right: Node | None = None\n\n    def __iter__(self) -> Iterator[float]:\n        if self.left:\n            yield from self.left\n        yield self.data\n        if self.right:\n            yield from self.right\n\n    @property\n    def is_sorted(self) -> bool:\n        if self.left and (self.data < self.left.data or not self.left.is_sorted):\n            return False\n        return not (\n            self.right and (self.data > self.right.data or not self.right.is_sorted)\n        )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    tree = Node(data=2.1, left=Node(data=2.0), right=Node(data=2.2))\n    print(f\"Tree {list(tree)} is sorted: {tree.is_sorted = }.\")\n    assert tree.right\n    tree.right.data = \"2.0\"\n    print(f\"Tree {list(tree)} is sorted: {tree.is_sorted = }.\")\n    tree.right = node(data=\"abc\")\n    print(f\"Tree {list(tree)} is sorted: {tree.is_sorted = }.\")",
    "fixed_code": "from __future__ import annotations\n\nfrom collections.abc import Iterator\nfrom dataclasses import dataclass\n\n\n@dataclass\nclass Node:\n    data: float\n    left: Node | None = None\n    right: Node | None = None\n\n    def __iter__(self) -> Iterator[float]:\n        if self.left:\n            yield from self.left\n        yield self.data\n        if self.right:\n            yield from self.right\n\n    @property\n    def is_sorted(self) -> bool:\n        if self.left and (self.data < self.left.data or not self.left.is_sorted):\n            return False\n        return not (\n            self.right and (self.data > self.right.data or not self.right.is_sorted)\n        )\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    tree = Node(data=2.1, left=Node(data=2.0), right=Node(data=2.2))\n    print(f\"Tree {list(tree)} is sorted: {tree.is_sorted = }.\")\n    assert tree.right\n    tree.right.data = 2.0\n    print(f\"Tree {list(tree)} is sorted: {tree.is_sorted = }.\")\n    tree.right.data = 2.1\n    print(f\"Tree {list(tree)} is sorted: {tree.is_sorted = }.\")",
    "source_file": "8.py"
  },
  {
    "error_type": "runtime",
    "buggy_code": "from __future__ import annotations\n\nfrom collections import Counter\nfrom random import random\n\n\nclass MarkovChainGraphUndirectedUnweighted:\n    def __init__(self):\n        self.connections = {}\n\n    def add_node(self, node: str) -> None:\n        self.connections[node] = {}\n\n    def add_transition_probability(\n        self, node1: str, node2: str, probability: float\n    ) -> None:\n        if node1 not in self.connections:\n            self.add_node(node1)\n        if node2 not in self.connections:\n            self.add_node(node2)\n        self.connections[node1][node2] = probability\n\n    def get_nodes(self) -> list[str]:\n        return list(self.connections)\n\n    def transition(self, node: str) -> str\n        current_probability = 0\n        random_value = random(\n\n        for dest in self.connections[node]:\n            current_probability += self.connections[node][dest]\n            if current_probability > random_value:\n                return dest\n        return \"\"\n\n\ndef get_transitions(\n    start: str, transitions: list[tuple[str, str, float]], steps: int\n) -> dict[str, int]:\n\n    graph = MarkovChainGraphUndirectedUnweighted()\n\n    for node1, node2, probability in transitions:\n        graph.add_transition_probability(node1, probability)\n\n    visited = Counter(graph.get_nodes())\n    node = start\n\n    for _ in range(steps):\n        node = graph.transition(node)\n        visited[node] += 1\n\n    return visited\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "fixed_code": "from __future__ import annotations\n\nfrom collections import Counter\nfrom random import random\n\n\nclass MarkovChainGraphUndirectedUnweighted:\n\n    def __init__(self):\n        self.connections = {}\n\n    def add_node(self, node: str) -> None:\n        self.connections[node] = {}\n\n    def add_transition_probability(\n        self, node1: str, node2: str, probability: float\n    ) -> None:\n        if node1 not in self.connections:\n            self.add_node(node1)\n        if node2 not in self.connections:\n            self.add_node(node2)\n        self.connections[node1][node2] = probability\n\n    def get_nodes(self) -> list[str]:\n        return list(self.connections)\n\n    def transition(self, node: str) -> str:\n        current_probability = 0\n        random_value = random()\n\n        for dest in self.connections[node]:\n            current_probability += self.connections[node][dest]\n            if current_probability > random_value:\n                return dest\n        return \"\"\n\n\ndef get_transitions(\n    start: str, transitions: list[tuple[str, str, float]], steps: int\n) -> dict[str, int]:\n\n    graph = MarkovChainGraphUndirectedUnweighted()\n\n    for node1, node2, probability in transitions:\n        graph.add_transition_probability(node1, node2, probability)\n\n    visited = Counter(graph.get_nodes())\n    node = start\n\n    for _ in range(steps):\n        node = graph.transition(node)\n        visited[node] += 1\n\n    return visited\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "source_file": "10.py"
  },
  {
    "error_type": "syntax",
    "buggy_code": "def floor(x: float) -> int:\n    return int(x) if x - int(x) >= 0 else int(x) - 1\n\n\nif __name__ == \"__main__\":\nimport doctest\n\ndoctest.testmod()",
    "fixed_code": "def floor(x: float) -> int:\n    return int(x) if x - int(x) >= 0 else int(x) - 1\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()",
    "source_file": "24.py"
  },
  {
    "error_type": "syntax",
    "buggy_code": "def hexagonal_numbers(length: int) -> list[int]\n\n    if length <== 0 or not isinstance(length, int):\n        raise ValueError \"Length must be a positive integer.\")\n    return [n * (2 * n - 1) for n in range(length)]\n\n\nif __name__ == \"__main__\":\n    print(hexagonal_numbers(length=5))\n    print(hexagonal_numbers(length=10))",
    "fixed_code": "def hexagonal_numbers(length: int) -> list[int]:\n\n    if length <= 0 or not isinstance(length, int):\n        raise ValueError(\"Length must be a positive integer.\")\n    return [n * (2 * n - 1) for n in range(length)]\n\n\nif __name__ == \"__main__\":\n    print(hexagonal_numbers(length=5))\n    print(hexagonal_numbers(length=10))",
    "source_file": "9.py"
  },
  {
    "error_type": "syntax",
    "buggy_code": "from __future__ import annotations\n\n\n# Extended Euclid\ndef extended_euclid(a: int, b: int -> tuple[int, int]:\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)\n\n# Uses ExtendedEuclid to find inverses\ndef chinese_remainder_theorem(n1: int, r1: int, n2: int, r2: int) -> int:\n    (x, y) = extended_euclid(n1, n2)\n    m = n1 * n2\n    n = r2 * x * n1 + r1 * y * n2\n    return (n % m + m) % m\n\n# This function find the inverses of a i.e., a^(-1)\ndef invert_modulo(a: int, n: int) -> int:\n    (b, x) = extended_euclid(a, n)\n    if b < 0:\n        b = (b % n + n) % n\n    return b\n\n\n$ Same a above using InvertingModulo\ndef chinese_remainder_theorem2(n1: int, r1: int, n2: int, r2: int) -> int:\n    x, y = invert_modulo(n1, n2), invert_modulo(n2, n1)\n    m = n1 * n2\n    n = r2 * x * n1 + r1 * y * n2\n    return (n % m + m) % m\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod(name=\"chinese_remainder_theorem\", verbose=True)\n    testmod(name=\"chinese_remainder_theorem2\", verbose=True)\n    testmod(name=\"invert_modulo\", verbose=True)\n    testmod(name=\"extended_euclid\", verbose=True)",
    "fixed_code": "from __future__ import annotations\n\n\n# Extended Euclid\ndef extended_euclid(a: int, b: int) -> tuple[int, int]:\n    if b == 0:\n        return (1, 0)\n    (x, y) = extended_euclid(b, a % b)\n    k = a // b\n    return (y, x - k * y)\n\n\n# Uses ExtendedEuclid to find inverses\ndef chinese_remainder_theorem(n1: int, r1: int, n2: int, r2: int) -> int:\n    (x, y) = extended_euclid(n1, n2)\n    m = n1 * n2\n    n = r2 * x * n1 + r1 * y * n2\n    return (n % m + m) % m\n\n\n# ----------SAME SOLUTION USING InvertModulo instead ExtendedEuclid----------------\n\n\n# This function find the inverses of a i.e., a^(-1)\ndef invert_modulo(a: int, n: int) -> int:\n    (b, x) = extended_euclid(a, n)\n    if b < 0:\n        b = (b % n + n) % n\n    return b\n\n\n# Same a above using InvertingModulo\ndef chinese_remainder_theorem2(n1: int, r1: int, n2: int, r2: int) -> int:\n    x, y = invert_modulo(n1, n2), invert_modulo(n2, n1)\n    m = n1 * n2\n    n = r2 * x * n1 + r1 * y * n2\n    return (n % m + m) % m\n\n\nif __name__ == \"__main__\":\n    from doctest import testmod\n\n    testmod(name=\"chinese_remainder_theorem\", verbose=True)\n    testmod(name=\"chinese_remainder_theorem2\", verbose=True)\n    testmod(name=\"invert_modulo\", verbose=True)\n    testmod(name=\"extended_euclid\", verbose=True)",
    "source_file": "5.py"
  }
]